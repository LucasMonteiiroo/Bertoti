# Lucas Rodrigues Monteiro da Silva

**Introdu√ß√£o**

Ol√°, √© um prazer recebe-lo em meu portif√≥lio. Sou o Lucas Rodrigues, graduando em Banco de Dados pela FATEC - Prof. Jessen Vidal.

Aqui, contar√° com uma descri√ß√£o sobre os meus projetos semestrais e como atuei em cada um, durante a minha forma√ß√£o. 
## Projeto 1

## PLIINB

Assistente Pessoal Virtual vinculado √† API Google Calendar, no qual o usu√°rio usar√° comandos de voz para acessar a Agenda Google atrav√©s da API, executar os comandos de consultar, editar e visualizar compromissos da agenda. Al√©m de consumir API do sexto semestre.

**Lista de comandos poss√≠veis:**

-   Consultar agenda;
-   Ler compromissos do dia;
-   Incluir compromisso;
-   Editar compromisso;
-   Excluir compromisso;
-   Fechar agenda.

-   ## Tecnologias utilizadas üîç

  **Python 3.6 (com Flask)** üõ†Ô∏è
* Ao optar por empregar o Flask no desenvolvimento da interface web da assistente virtual, os usu√°rios ser√£o beneficiados por uma intera√ß√£o intuitiva e acess√≠vel. Adicionalmente, o framework proporciona a flexibilidade essencial para ampliar e aprimorar as funcionalidades da assistente ao longo do tempo, adaptando-se √†s mudan√ßas e requisitos que possam surgir durante a evolu√ß√£o do projeto. Essa abordagem oferece uma base s√≥lida para aperfei√ßoar a experi√™ncia do usu√°rio e expandir as capacidades da assistente conforme as demandas do contexto.

**Spyder (IDE)** üëæ
* O Spyder se destaca como uma ferramenta essencial para a cria√ß√£o da assistente virtual. Como uma IDE dedicada ao Python, oferece um ambiente familiar e intuitivo para os desenvolvedores. Sua interface amig√°vel simplifica o processo de escrita, oferecendo n√£o apenas uma interface amig√°vel, mas tamb√©m ferramentas poderosas e integradas que facilitam desde a manipula√ß√£o de dados at√© a depura√ß√£o e personaliza√ß√£o do c√≥digo Python.
    
**Agenda do Google (API Google Calendar)** üíª 
* A integra√ß√£o da Agenda do Google, por meio da API Google Calendar, desempenha um papel fundamental no projeto da assistente virtual. Essa integra√ß√£o permite que a assistente acesse, gerencie e utilize informa√ß√µes diretamente a partir do Google Calendar.

* A assistente pode agendar compromissos, criar lembretes, verificar disponibilidade de hor√°rios e at√© mesmo realizar confirma√ß√µes ou cancelamentos de eventos na agenda dos usu√°rios. Isso se traduz em uma experi√™ncia mais conveniente e personalizada, onde a assistente pode fornecer informa√ß√µes relevantes sobre eventos agendados, lembretes de compromissos, e at√© mesmo automatizar algumas intera√ß√µes relacionadas √† agenda.
    
**Trello** üìä 
* A utiliza√ß√£o do trello serviu para dividir as tarefas em cart√µes, que podem representar desde funcionalidades espec√≠ficas da assistente at√© atividades de desenvolvimento, testes, e revis√µes

 **StackEdit** üìÅ
 * A funcionalidade de colabora√ß√£o em tempo real do StackEdit √© valiosa para equipes distribu√≠das ou que trabalham remotamente. V√°rios membros podem editar um documento simultaneamente, visualizando as altera√ß√µes em tempo real, o que facilita a revis√£o, o compartilhamento de ideias e a tomada de decis√µes colaborativas.

  ## Contribui√ß√µes pessoais üéì

 <details>
 
<summary>Fun√ß√£o autenticacao_google()</summary>
<br>
Esta fun√ß√£o verifica a exist√™ncia do arquivo token.pickle, que cont√©m as credenciais de acesso. Caso as credenciais n√£o existam, sejam inv√°lidas ou estejam expiradas, o c√≥digo inicia um processo de renova√ß√£o, verificando se h√° um token de atualiza√ß√£o dispon√≠vel (refresh_token) para as credenciais expiradas. Em caso positivo, as credenciais s√£o renovadas. Caso contr√°rio, o c√≥digo inicia um novo fluxo de autentica√ß√£o utilizando o arquivo credentials.json. Ao finalizar esses procedimentos, a fun√ß√£o retorna um servi√ßo autenticado, pronto para interagir com a API do Google Calendar de forma segura e autorizada.

```python
def autenticacao_google():
    creds = None
    if os.path.exists('token.pickle'):
        with open('token.pickle', 'rb') as token:
            creds = pickle.load(token)

    if not creds or not creds.valid:
        if creds and creds.expired and creds.refresh_token:
            creds.refresh(Request())
        else:
            flow = InstalledAppFlow.from_client_secrets_file(
                'credentials.json', SCOPES)
            creds = flow.run_local_server(port=0)

        with open('token.pickle', 'wb') as token:
            pickle.dump(creds, token)

    service = build('calendar', 'v3', credentials=creds)
    return service
    
 ```
 </details>

<details>
<summary>fun√ß√£o eventos(day, service)</summary>
<br>
O c√≥digo da fun√ß√£o eventos(day, service) em Python √© respons√°vel por listar os eventos do Google Calendar para um determinado dia. Ele come√ßa combinando a data inicial e final do dia especificado para criar um intervalo de tempo para a busca de eventos. Em seguida, utiliza o servi√ßo da API do Google Calendar para buscar os eventos nesse intervalo de tempo, utilizando os par√¢metros de tempo timeMin e timeMax.

Se n√£o existirem eventos para o dia especificado, o c√≥digo imprime uma mensagem informando que n√£o h√° compromissos e espera por uma entrada para continuar.

Caso existam eventos, o c√≥digo limpa a tela, lista o intervalo de tempo e itera sobre cada evento encontrado. Para cada evento, imprime o t√≠tulo e a data/hor√°rio de in√≠cio. Al√©m disso, chama a fun√ß√£o editarEventos(events, service) para possibilitar a edi√ß√£o dos eventos listados. Esta fun√ß√£o auxiliar permite a manipula√ß√£o dos eventos presentes no Google Calendar.
 
```python
def eventos(day, service):
    date = datetime.datetime.combine(day, datetime.datetime.min.time())
    end_date = datetime.datetime.combine(day, datetime.datetime.max.time())
    utc = pytz.UTC
    date_utc = date.astimezone(utc)
    end_date_utc = end_date.astimezone(utc)
    
    events_result = service.events().list(calendarId='primary', 
                                          timeMin=date_utc.isoformat(),
                                          timeMax=end_date_utc.isoformat(),
                                          singleEvents=True,
                                          orderBy='startTime').execute()
    events = events_result.get('items', [])

    if not events:
        print('N√£o existem compromissos neste dia.')
        input("Pressione uma tecla para continuar...")
    else:
        clear()
        lin()
        print("Listando Eventos ")
        print("Inicio:", date)
        print("Fim:", end_date)
        for event in events:
            lin()
            print("Titulo:"+ event['summary'])
            print("Data e Hor√°rio: "+ event['start'].get('dateTime'))
            lin()
            print("")

        editarEventos(events, service)

```
 </details>

****

## Projeto 2

**Empresa parceira**

## TecSUS
![image](https://github.com/LucasMonteiiroo/Bertoti/blob/main/Metodologia/Logos/logo_tecsus_horizontal.png)

A TecSUS realiza a gest√£o de contas de utilidades (√°gua e energia) dos seus clientes. Todos os meses milhares de contas devem ser digitadas manualmente no sistema para a realiza√ß√£o de an√°lises de contratos e an√°lises de consumo. Desta forma, para facilitar a digita√ß√£o das contas precisamos de um sistema que permita o cadastro de cada conta de forma r√°pida e √°gil, sem a necessidade de utiliza√ß√£o do mouse, apenas por comandos do teclado.

## Tecnologias utilizadas üîç

**Eclipse**
* No contexto espec√≠fico da TecSUS, onde √© necess√°rio criar um sistema para facilitar a digita√ß√£o das contas de utilidades (√°gua e energia) dos clientes, o Eclipse pode ser uma excelente escolha para desenvolver essa aplica√ß√£o. Ele permite criar uma interface amig√°vel e eficiente, adaptada para facilitar o cadastro r√°pido e √°gil das contas, priorizando a entrada de dados por meio de comandos do teclado, sem depender do uso do mouse.

**MySQL**
* O MySQL √© um sistema de gerenciamento de banco de dados relacional muito popular, conhecido por ser de c√≥digo aberto, confi√°vel e amplamente utilizado em muitas aplica√ß√µes e sistemas em todo o mundo.

* No contexto da TecSUS, onde √© necess√°rio gerenciar e armazenar dados relacionados √†s contas de utilidades dos clientes (como dados de consumo de √°gua e energia), o MySQL pode desempenhar um papel fundamental como um banco de dados confi√°vel.

**BrModelo 2.0**
* No contexto da TecSUS, onde √© essencial gerenciar e organizar os dados das contas de utilidades dos clientes, o BRModelo pode ser empregado para criar um modelo ER representando a estrutura das informa√ß√µes necess√°rias para o armazenamento no banco de dados, como detalhes das contas, informa√ß√µes de consumo, informa√ß√µes dos clientes, entre outros.

## Contribui√ß√µes pessoais üéì
<details>
<summary>fun√ß√£o eventos(day, service)</summary>
<br>

</details>

****


## Projeto 3

**Empresa parceira**

## IACIT solu√ß√µes tecnol√≥gicas S.A.

![image](https://github.com/LucasMonteiiroo/Bertoti/assets/65603418/f5b6e3b7-b3d5-41f5-9747-7b3c42605942)


Foi proposto um desafio de desenvolver um sistema que possa importar dados meteorol√≥gicos de arquivos CSV fornecidos pela empresa IACIT. O sistema deve armazenar esses dados em um banco de dados e permitir a gera√ß√£o de relat√≥rios solicitados pelos clientes da empresa. A aplica√ß√£o web deve ser capaz de filtrar os registros com base em regi√µes, estados, esta√ß√µes, tipos de dados e intervalos de datas. Al√©m disso, ela deve exibir as informa√ß√µes em forma de gr√°ficos e cards. Por fim, o sistema deve permitir a gera√ß√£o de relat√≥rios com base nas pesquisas realizadas pelos usu√°rios.

* Requisitos funcionais exigidos: Cadastro de esta√ß√µes, cadastro de estados e regi√µes, importa√ß√£o de dados e gera√ß√£o de relat√≥rios.

* Requisitos n√£o funcionais exigidos: Sistema Web, linguagem java, banco de dados relacional e documenta√ß√µes.

## Tecnologias utilizadas üîç

**HTML, CSS e Javascript**  üíª 

* Para criar a interface gr√°fica da aplica√ß√£o, foram combinadas as linguagens de marca√ß√£o HTML e CSS com a linguagem de programa√ß√£o JavaScript. O HTML √© respons√°vel pela estrutura b√°sica da p√°gina da web, enquanto o CSS define o estilo visual e a apar√™ncia da p√°gina. J√° o JavaScript √© utilizado para adicionar interatividade √† p√°gina, permitindo que os usu√°rios realizem a√ß√µes e que os dados sejam exibidos e atualizados dinamicamente. Ao utilizar o HTML, CSS e JavaScript em conjunto, foi poss√≠vel desenvolver uma interface amig√°vel e intuitiva para os usu√°rios da aplica√ß√£o. Isso permite que eles visualizem os dados meteorol√≥gicos e gerem relat√≥rios de forma f√°cil e eficiente. Al√©m disso, a aplica√ß√£o fez uso da biblioteca de JavaScript chamada Charts, que possibilitou a apresenta√ß√£o dos dados em forma de gr√°ficos de maneira adequada.

**Java** üõ†Ô∏è

* Para desenvolver o back-end da aplica√ß√£o, foi utilizada a linguagem Java em conjunto com o framework Spring Boot. O Spring Boot √© uma estrutura que agiliza a cria√ß√£o de aplicativos web em Java, oferecendo um conjunto de ferramentas e bibliotecas que facilitam o desenvolvimento. Com o uso do Java e do Spring Boot, foi poss√≠vel criar o back-end da aplica√ß√£o de forma eficiente, aproveitando as vantagens proporcionadas por essa combina√ß√£o de tecnologias.

**PostgresSQL** üêò

* Para armazenar todos os dados meteorol√≥gicos, dados de esta√ß√µes e regi√µes, foi utilizado o banco de dados PostgreSQL, que √© um banco de dados relacional. O PostgreSQL foi escolhido devido √† sua versatilidade, interface simplificada e funcionalidades intuitivas, o que facilitou o uso e o gerenciamento do banco de dados. Sua efici√™ncia e desempenho contribu√≠ram para o armazenamento tranquilo dos milh√µes de dados meteorol√≥gicos importados, garantindo um bom desempenho do sistema.

## Contribui√ß√µes pessoais üéì

 Durante o projeto, trabalhando como PO, pude aprimorar minhas habilidades nessa fun√ß√£o. Em um ambiente √°gil e colaborativo, a metodologia Scrum desempenha um papel fundamental na gest√£o de projetos. O Product Owner (PO) √© respons√°vel por definir as prioridades e guiar a equipe para alcan√ßar os objetivos do produto. Neste contexto, a prioriza√ß√£o de tarefas √© uma atividade crucial para garantir o sucesso do projeto.
 
 Abaixo √© possivel visualizar alguns t√≥picos que do que precisiei trabalhar com o time. 

 <details>
 
<summary>Compreens√£o das necessidades do cliente</summary>
 <br>
 O primeiro passo para o PO √© entender profundamente as necessidades do cliente e os objetivos do produto. Isso envolve a comunica√ß√£o efetiva com os stakeholders e a coleta de feedback cont√≠nuo. Ao ter uma vis√£o clara das expectativas, o PO pode definir prioridades com base na entrega de valor para o cliente.
 
 </details>
 
 <details>
 <summary> Defini√ß√£o do Product Backlog </summary>
 <br>
 O Product Backlog √© uma lista ordenada de itens que representam as funcionalidades, requisitos e melhorias do produto. O PO, em colabora√ß√£o com a equipe, √© respons√°vel por criar e manter esse backlog. A prioriza√ß√£o das tarefas √© feita atribuindo um valor de neg√≥cio a cada item, considerando seu impacto no sucesso do produto
 
 </details>
 
  <details>
 <summary> Reuni√µes de Planejamento </summary>
 <br>
 Durante as reuni√µes de planejamento do Sprint, o PO trabalha em conjunto com a equipe para definir as tarefas que ser√£o inclu√≠das no Sprint Backlog. Com base na prioriza√ß√£o do Product Backlog, o PO seleciona as tarefas mais relevantes para o Sprint atual. A equipe discute os detalhes e estima o esfor√ßo necess√°rio para concluir cada tarefa
 
 </details>
   
   <details>
 <summary> Colabora√ß√£o cont√≠nua </summary>
 <br>
 Durante o Sprint, o PO mant√©m uma comunica√ß√£o aberta com a equipe. Ele fornece esclarecimentos sobre os requisitos, responde a perguntas e ajusta a prioridade, se necess√°rio. A colabora√ß√£o cont√≠nua √© essencial para garantir que as tarefas estejam alinhadas com as expectativas e que a equipe possa trabalhar de forma eficiente.
 
 </details>
 
   <details>
 <summary> Adpata√ß√£o ao longo do tempo </summary>
 <br>
A prioriza√ß√£o de tarefas √© um processo din√¢mico. √Ä medida que o projeto evolui, novas informa√ß√µes e feedback podem surgir, o que pode exigir ajustes nas prioridades. O PO deve estar aberto a essas mudan√ßas e ser capaz de adaptar-se √†s necessidades em constante mudan√ßa.
 
 </details>
 
 Colaborei tamb√©m com a implementa√ß√£o da regra de negocio a nossa modelagem de dados, onde demos o inicio do banco e estruturamos o projeto. 
 
   <details>
 <summary> Modelagem </summary>
 <br>
Nesse caso, a cidade em si serve como a esta√ß√£o que desempenha o papel de coordenar e distribuir as informa√ß√µes entre as diversas entidades envolvidas. Essa estrutura permite que as entidades dependam da cidade/esta√ß√£o para acessar e compartilhar as informa√ß√µes necess√°rias para suas atividades. A cidade/esta√ß√£o atua como um ponto central de refer√™ncia, garantindo a integridade e consist√™ncia das informa√ß√µes, e facilitando a colabora√ß√£o eficiente entre as partes envolvidas. Essa abordagem permite uma gest√£o mais eficaz e uma melhor organiza√ß√£o dos dados, contribuindo para o sucesso e efici√™ncia geral das opera√ß√µes.
 <br>
 <img src="caminho_da_imagem.png" alt="Texto alternativo" width="300" height="200">

 </details>
 
 
 ## Projeto 4

**Empresa parceira**

## Embraer 
Atualmente, muitos pilotos trabalham como "freelancers" e n√£o operam apenas uma aeronave/frota, o que dificulta o reconhecimento de determinados equipamentos e vers√µes de software instalados na aeronave. Al√©m disso, o piloto nem sempre tem acesso r√°pido a todos os manuais e documentos da aeronave, o que dificulta o seu conhecimento sobre a aeronave e as suas capacidades.

**Requisitos Funcionais**
* Utiliza√ß√£o de APIs para futura integra√ß√£o com sistemas de plataformas m√≥veis
- Acesso √† base de dados de clientes (utilizador, password e equipamento)
- Os utilizadores devem ter perfis diferentes (administrador, edi√ß√£o e consulta)
- Possibilidade de aplica√ß√£o de filtros de sele√ß√£o (por categoria de artigo)
- Visualiza√ß√£o de ficheiros PDF na App e possibilidade de exporta√ß√£o no mesmo formato, com registo da data de gera√ß√£o do ficheiro e do utilizador.

## Tecnologias utilizadas üîç

**Java e Spring**
O back-end da aplica√ß√£o foi desenvolvido em Java juntamente com o framework Spring, onde foi realizada a l√≥gica das regras de neg√≥cio para determina√ß√£o de quais itens eram considerados instalados, instal√°veis ou n√£o instal√°veis de acordo com os chassis que fossem pesquisados. Atrav√©s do Spring Data foi poss√≠vel realizar consultas de forma mais eficiente no banco de dados para tratamento das l√≥gicas e condi√ß√µes no back-end.

**Oracle Autonomous Database**
Para armazenamento dos dados, foi utilizado o Oracle Autonomous Database, um banco relacional em nuvem. Foi escolhido devido a possibilidade de consultar o banco atrav√©s da internet, proporcionando uma melhor acessibilidade, praticidade e flexibilidade. Al√©m do mais, tamb√©m proporcionou maior seguran√ßa, tanto no controle de acesso ao banco, quanto na consist√™ncia dos dados, pois eram gerados backups autom√°ticos que protegiam contra a perda de dados e facilitavam a recupera√ß√£o em caso de falhas de opera√ß√£o.








 
 
